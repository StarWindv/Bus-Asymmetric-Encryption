# Bus-Asymmetric-Encryption 🚌🔐

## 写在开头的话

这是我在 `2025年1月31日` 于公交车上想到的一个简单的非对称加密算法。  
A simple asymmetric encryption algorithm that came to mind on the bus.  
这只是一个记录，**不建议使用此算法**，因为我也不能确定是否存在其他问题。但显而易见的是，它非常简单——它的一部分是线性的加密算法。

---

## 想法分享 💡

1. **生成密钥对**  
   - 取一个长度为256的整数 `A`，将其复制并倒序得到 `B`。  
   - 将 `A` 和 `B` 的每一位相乘再相加，得到 `C`。  
     （例如：`24` → `24` 和 `42` → `2*4 + 4*2 = 8 + 8 = 16`）  
   - 将 `A` 视为一个数列（如 `231` → `2, 3, 1`），排序后得到数列 `D`（如 `1, 2, 3`），再将其视为整数（如 `123`）。  
   - 将 `D` 与 `C` 的每一位相乘再相加（原理同上）。  

2. **填充与扩展**  
   - 由于 `C` 和 `D` 较短，可以按照某种规则进行填充。  
     例如：计算 `A` 的因子中不大于 `100` 的最大质数 `X`，将 `C` 和 `D` 分别乘以 `X` 得到 `C'` 和 `D'`。  
   - 按照 `0~9` 的顺序循环填充到 `128` 位，继续进行计算。  
   - 最终的 `C'` 和 `D'` 作为公钥，用于加密 Unicode 数据。

---

## 效果测试 🧪

相关测试方法请见 [`Effect_Testing.py`](./Effect_Testing.py)。  
（注：测试函数是根据定义自己编写的，不确定是否存在理解错误导致测试结果不准确。）

### 测试结果
- **密钥敏感性测试**  
  - 汉明距离: `66`  
  - 比特变化率: `51.56%`  

- **加密性能测试**  
  - 加密 `1KB` 数据所需时间: `0.0002 秒`  
  - 加密 `10KB` 数据所需时间: `0.0091 秒`  
  - 加密 `100KB` 数据所需时间: `0.1442 秒`  

- **抗碰撞测试**  
  - 在次数为 `1,000,000`、文本长度为 `1,000` 时通过测试。  
  （未测试更大次数和更长的数据情况。）  

- **边界测试**  
  - 通过了 `1MB` 数据、空字符、单字符的边界测试。

---

## 总结 📝

这个算法虽然简单，但在某些场景下可能具有一定的实用性(比如非对称加密的入门教学)。不过，由于其设计较为简单，可能存在潜在的安全问题，因此不建议用于实际加密需求。欢迎提出改进建议或测试反馈！  
🚀 Happy Coding!
